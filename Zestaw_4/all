/*
 * Simulation.cpp
 *
 *  Created on: 10 gru 2023
 *      Author: oramus
 */

#include "Simulation.h"
#include <math.h>
#include <iostream>

using namespace std;

Simulation::Simulation(Force *_force, double _dt, bool _molecularStatic) {
	force = _force;
	particles = { };
	x = y = m = Fx = Fy = Vx = Vy = { };

	dt = _dt;
	dt_2 = dt / 2.0;
	molecularStatic = _molecularStatic;
}

void Simulation::initialize(DataSupplier *supplier) {
	particles = supplier->points();
	allocateMemory();

	for (int idx = 0; idx < particles; idx++) {
		x[idx] = supplier->x(idx);
		y[idx] = supplier->y(idx);
		m[idx] = supplier->m(idx);
		Vx[idx] = Vy[idx] = Fx[idx] = Fy[idx] = { 0.0 };
	}
}

void Simulation::allocateMemory() {
	x = new double[particles];
	y = new double[particles];
	m = new double[particles];
	Fx = new double[particles];
	Fy = new double[particles];
	Vx = new double[particles];
	Vy = new double[particles];
}

void Simulation::step() {
	updateVelocity();
	updatePosition();
	if (molecularStatic)
		preventMoveAgainstForce();
}

void Simulation::updateVelocity() {

	double oldFx, oldFy;
	double dx, dy, distance, frc;

	for (int idx = 0; idx < particles; idx++) {
		oldFx = Fx[idx];
		oldFy = Fy[idx];
		Fx[idx] = Fy[idx] = 0.0;
		for (int idx2 = 0; idx2 < idx; idx2++) {
			dx = x[idx2] - x[idx];
			dy = y[idx2] - y[idx];

			distance = sqrt(dx * dx + dy * dy);

			frc = force->value(distance);

			Fx[idx] += frc * dx / distance;
			Fy[idx] += frc * dy / distance;
		}

		for (int idx2 = idx+1; idx2 < particles; idx2++) {
			dx = x[idx2] - x[idx];
			dy = y[idx2] - y[idx];

			distance = sqrt(dx * dx + dy * dy);

			frc = force->value(distance);

			Fx[idx] += frc * dx / distance;
			Fy[idx] += frc * dy / distance;
		}
		Vx[idx] += dt_2 * (Fx[idx] + oldFx) / m[idx];
		Vy[idx] += dt_2 * (Fy[idx] + oldFy) / m[idx];
	}
}

void Simulation::updatePosition() {
	for (int idx = 0; idx < particles; idx++) {
		x[idx] += dt * (Vx[idx] + dt_2 * Fx[idx] / m[idx]);
		y[idx] += dt * (Vy[idx] + dt_2 * Fy[idx] / m[idx]);
	}
}

void Simulation::preventMoveAgainstForce() {
	double dotProduct;
	for (int idx = 0; idx < particles; idx++) {
		dotProduct = Vx[idx] * Fx[idx] + Vy[idx] * Fy[idx];
		if (dotProduct < 0.0) {
			Vx[idx] = Vy[idx] = { 0.0 };
		}
	}
}

double Simulation::Ekin() {
	double ek = 0.0;

	for (int idx = 0; idx < particles; idx++) {
		ek += m[idx] * (Vx[idx] * Vx[idx] + Vy[idx] * Vy[idx]) * 0.5;
	}

	return ek;
}

void Simulation::pairDistribution(double *histogram, int size, double coef) {
	for (int i = 0; i < size; i++)
		histogram[i] = 0;

	const double maxDistanceSQ = size * coef * size * coef;
	double dx, dy;
	double distance;
	int idx;

	for (int idx1 = 0; idx1 < particles; idx1++) {
		for (int idx2 = 0; idx2 < idx1; idx2++) {
			dx = x[idx2] - x[idx1];
			dy = y[idx2] - y[idx1];
			distance = dx * dx + dy * dy;
			if (distance < maxDistanceSQ) {
				distance = sqrt(distance);
				idx = (int) (distance / coef);
				histogram[idx]++;
			}
		}
	}

	for (int i = 0; i < size; i++) {
		distance = (i + 0.5) * coef;
		histogram[i] *= 1.0 / (2.0 * M_PI * distance * coef);
	}
}

double Simulation::avgMinDistance() {
	double sum = { };

	for (int i = 0; i < particles; i++)
		sum += minDistance(i);

	return sum / particles;
}

double Simulation::minDistance(int idx) {
	double dSqMin = 10000000.0;
	double dx, dy, distanceSQ;

	double xx = x[idx];
	double yy = y[idx];

	for (int i = 0; i < idx; i++) {
		dx = xx - x[i];
		dy = yy - y[i];
		distanceSQ = dx * dx + dy * dy;
		if (distanceSQ < dSqMin)
			dSqMin = distanceSQ;
	}
	for (int i = idx + 1; i < particles; i++) {
		dx = xx - x[i];
		dy = yy - y[i];
		distanceSQ = dx * dx + dy * dy;
		if (distanceSQ < dSqMin)
			dSqMin = distanceSQ;
	}

	return sqrt(dSqMin);
}

Simulation::~Simulation() {
}


/*
 * SimpleDataSupplier.cpp
 *
 *  Created on: 11 gru 2023
 *      Author: oramus
 */

#include "SimpleDataSupplier.h"
#include <iostream>

using namespace std;

SimpleDataSupplier::SimpleDataSupplier( int _pointsSqrt, double _distance, double _mass )  : DataSupplier( _pointsSqrt * _pointsSqrt ),
distance( _distance ), pointsSqrt( _pointsSqrt ), mass( _mass ) {
}

void SimpleDataSupplier::setData() {
	int idx {};
	for ( int i = 0; i < pointsSqrt; i++ )
		for ( int j = 0; j < pointsSqrt; j++ ) {
			xptr[idx] = j * distance;
			yptr[idx] = i * distance;
			mptr[idx] = mass;
			idx++;
		}
}

SimpleDataSupplier::~SimpleDataSupplier() {
}

/*
 * MyForce.cpp
 *
 *  Created on: 10 gru 2023
 *      Author: oramus
 */

#include "MyForce.h"
#include <math.h>

MyForce::MyForce() {
}

MyForce::~MyForce() {
}

double MyForce::value( double x ) {
	return -AMPLITUDE * exp( -x * x * DECAY ) * cos( x / LENGTH );
}


/*
 * main.cpp
 *
 *  Created on: 12 gru 2023
 *      Author: oramus
 */

#include "Force.h"
#include "MyForce.h"
#include "Simulation.h"
#include "DataSupplier.h"
#include "SimpleDataSupplier.h"

#include <iostream>

using namespace std;


///////////////////////////////////////
//////// DANE DLA SYMULACJI ///////////
///////////////////////////////////////

constexpr int HISTOGRAM_SIZE = 20;
constexpr double HISTOGRAM_LENGTH_PER_BIN = 0.2;
constexpr double DT = 0.02;
constexpr double DISTANCE = 1.0;
constexpr double MASS = 1.0;
constexpr int STEPS = 100000;
constexpr int REPORT_PERIOD = 500;
constexpr int PARTICLES_SQRT = 20;

void showReport(int i, Simulation *s, double *v);

int main(int argc, char **argv) {

	double *v = new double[HISTOGRAM_SIZE];

	Force *force = new MyForce();

	DataSupplier *supplier = new SimpleDataSupplier(PARTICLES_SQRT, DISTANCE,
			MASS);
	supplier->initializeData();

	Simulation *simulation = new Simulation(force, DT, true);
	simulation->initialize(supplier);

	for (int step = 0; step < STEPS; step++) {
		if (step % REPORT_PERIOD == 0) {
			showReport(step, simulation, v);
		}
		simulation->step();
	}
	showReport(STEPS, simulation, v);
}

void showReport(int step, Simulation *s, double *v) {
	s->pairDistribution(v, HISTOGRAM_SIZE, HISTOGRAM_LENGTH_PER_BIN);
	cout << "Step: " << step << " Ekin = " << s->Ekin()
			<< " <min(NNdistance)> = " << s->avgMinDistance() << endl;
	for (int j = 0; j < HISTOGRAM_SIZE; j++) {
		cout << "v[" << j << "] = " << v[j] << endl;
	}
}


/*
 * Force.cpp
 *
 *  Created on: 10 gru 2023
 *      Author: oramus
 */

#include "Force.h"

Force::Force() {
}

/*
 * DataSupplier.cpp
 *
 *  Created on: 11 gru 2023
 *      Author: oramus
 */

#include "DataSupplier.h"

DataSupplier::DataSupplier(int points) : pts( points ){
	xptr = new double[points];
	yptr = new double[points];
	mptr = new double[points];
}

int DataSupplier::points() {
	return pts;
}

double DataSupplier::x(int idx) {
	return xptr[idx];
}

double DataSupplier::y(int idx) {
	return yptr[idx];
}

double DataSupplier::m(int idx) {
	return mptr[idx];
}

void DataSupplier::initializeData() {
	setData();
}

DataSupplier::~DataSupplier() {
}
